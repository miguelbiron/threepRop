% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/3prop_scores.R
\name{three_prop_cv}
\alias{three_prop_cv}
\title{Estimate 3prop weights using double cross-validation}
\usage{
three_prop_cv(M, y, R = 3L, n_folds = 3L, reg = 1e-09)
}
\arguments{
\item{M}{normalized affinity matrix, as returned by \code{normalize_A()}, of
size \code{N x N}. Must be of class \code{sparseMatrix}.}

\item{y}{vector of labels, of length \code{N}. Must be of class
\code{sparseVector}.}

\item{R}{maximum length of the random walks to consider. The default 3 is the
usual for 3prop.}

\item{n_folds}{number of CV folds to use in both inner and outer CV loops.}

\item{reg}{regularization parameter for LDA.}
}
\value{
A list with two elements: a matrix of size \code{R x n_folds},
containing the weights estimated for each (outer) CV iteration, and a vector
of length \code{n_folds} containing the AUROC for each such iteration.
}
\description{
This function estimates the weights for the 3prop algorithm using a double
cross-validation procedure.
}
\details{
By double cross-validation (CV), we mean that there are two CV loops, one
nested within the other. The first loop deals with calculating the random
walk features, while the second loop deals with estimating the coefficients
alpha associated to those features.

Additionally, the function returns computes the area under the ROC curve
(AUROC) for every fold in the outer CV loop.
}
\examples{
sim_SBM = simulate_simple_SBM(25L, 0.2, 0.001, 0.25)
M = normalize_A(sim_SBM$A, "asym")
three_prop_cv(M=M, y=sim_SBM$y)

}
\references{
Mostafavi, S., Goldenberg, A., & Morris, Q. (2012). Labeling nodes using
three degrees of propagation. \emph{PloS one, 7}(12), e51947.
}
